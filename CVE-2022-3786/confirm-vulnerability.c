/* This file is adapted from the OpenSSL test created after the CVE. See:
** https://github.com/openssl/openssl/commit/a0af4a3c8b18c435a5a4afb28b3ad1a2730e6ea8#diff-83399d92c96bb1f4616b5c6f090053b95834cdbc7bb37bb0d835d1555f69e8ad
*/

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

/* From punycode test. See link above */
#include <openssl/crypto.h>
#include <string.h>
#include "crypto/punycode.h"
#include "internal/nelem.h"

#define TEST_mem_eq(a, m, b, n) test_mem_eq(__FILE__, __LINE__, #a, #b, a, m, b, n)
#define TEST_false(a)        test_false(__FILE__, __LINE__, #a, (a) != 0)

int test_mem_eq(const char *file, int line, const char *st1, const char *st2,
                const void *s1, size_t n1, const void *s2, size_t n2)
{
    if (s1 == NULL && s2 == NULL)
        return 1;
    if (n1 != n2 || s1 == NULL || s2 == NULL || memcmp(s1, s2, n1) != 0) {
        return 0;
    }
    return 1;
}
int test_false(const char *file, int line, const char *s, int b)
{
    if (!b)
        return 1;
    return 0;
}

static int test_puny_overrun(void)
{
    static const unsigned int out[] = {
        0x0033, 0x5E74, 0x0042, 0x7D44, 0x91D1, 0x516B, 0x5148, 0x751F
    };
    static const char *in = "3B-ww4c5e180e575a65lsy2b";
    unsigned int buf[OSSL_NELEM(out)];
    unsigned int bsize = OSSL_NELEM(buf) - 1;

     if (!TEST_false(ossl_punycode_decode(in, strlen(in), buf, &bsize))) {
        if (TEST_mem_eq(buf, bsize * sizeof(*buf), out, sizeof(out)))
            puts("CRITICAL: buffer overrun detected!");
        return 0;
    }
    return 1;
}

static int test_puny_overrun_crash(void)
{
    char* in = "3B-ww4c5e180e575a65lsy2b";
    unsigned int out[] = {
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // Only 7-bytes now!
    };

    unsigned int bsize = OSSL_NELEM(out); // The actual size of our buffer

    int result = ossl_punycode_decode(in, strlen(in), out, &bsize);

    return 1;
}

#define A2ULABEL_SIZE 512
static int test_puny_overrun_large(void)
{
    unsigned int outlen = A2ULABEL_SIZE;
    // Should produce 513 sized output....
    static const char* in = "3B-ww4c5e180e575a65lsy2b3B-ww4c5e180e575a65lsy2b3B-ww4c5e180e575a65lsy2b3B-ww4c5e180e575a65lsy2b3B-ww4c5e180e575a65lsy2b3B-ww4c5e180e575a65lsy2b3B-ww4c5e180e575a65lsy2b3B-ww4c5e180e575a65lsy2b3B-ww4c5e180e575a65lsy2b3B-ww4c5e180e575a65lsy2b3B-ww4c5e180e575a65lsy2b3B-ww4c5e180e575a65lsy2b3B-ww4c5e180e575a65lsy2b3B-ww4c5e180e575a65lsy2b3B-ww4c5e180e575a65lsy2b3B-ww4c5e180e575a65lsy2b3B-ww4c5e180e575a65lsy2b3B-ww4c5e180e575a65lsy2b3B-ww4c5e180e575a65lsy2b3B-ww4c5e180e575a65lsy2b3B-ww4c5e180e575a65lsy2b3B-ww4c5e180e575a65lsy2ba";
    unsigned int out[A2ULABEL_SIZE];
    memset(out, 0xdd, sizeof(out));

    int result = ossl_punycode_decode(in, strlen(in), out, &outlen);

    return 1;
}

int main(int argc, char ** argv) {
    return test_puny_overrun_large();
}